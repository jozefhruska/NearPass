import functions, {
  CallableContext,
  HttpsError,
  HttpsSuccess,
} from './functions';
import {AES, enc} from 'crypto-js';
import firestore from './firestore';
import {UserData} from './types';


type PasswordRecord = {
  index: number;
  link?: string;
  passwordName: string;
  password: string;
  username?: string;
}

export const secondRoundDecryptInternal = async function(
    data: {
    passwordRecord: PasswordRecord,
    userId: string,
  },
    context: CallableContext,
): Promise<{ passwordRecord: PasswordRecord, status: string}> {
  const {userId, passwordRecord} = data;

  if (userId === undefined) {
    throw HttpsError('invalid-argument', 'Missing mandatory parameter: userId');
  }

  if (typeof userId !== 'string') {
    // eslint-disable-next-line new-cap
    throw HttpsError(
        'invalid-argument',
        'Invalid parameter: userId (incorrect type)'
    );
  }

  if (typeof passwordRecord.passwordName !== 'string') {
    throw HttpsError(
        'invalid-argument',
        'Invalid parameter: passwordRecord (invalid type of passwordName)'
    );
  }

  if (typeof passwordRecord.password !== 'string') {
    throw HttpsError(
        'invalid-argument',
        'Invalid parameter: passwordRecord (invalid type of password)'
    );
  }

  if (passwordRecord.link !== undefined && typeof passwordRecord.link !== 'string') {
    throw HttpsError(
        'invalid-argument',
        'Invalid parameter: passwordRecord (invalid type of link)',
    );
  }

  if (passwordRecord.username !== undefined && typeof passwordRecord.username !== 'string') {
    throw HttpsError(
        'invalid-argument',
        'Invalid parameter: passwordRecord (invalid type of username)',
    );
  }
  const userRef = firestore.collection('users').doc(userId);
  const userDoc = await userRef.get();
  const userData = userDoc.data() as UserData | null;
  const {
    password,
    passwordName,
    link,
    username,
    index,
  } = passwordRecord;

  // If we don't have the phrase, it is possible that this user only has
  // one round of encryption only, so return unchanged object
  if (!userData?.autoGeneratedPassPhrase) {
    return {
      passwordRecord,
      ...HttpsSuccess,
    };
  }
  const {
    autoGeneratedPassPhrase,
  } = userData;
  const encryptedPassword = AES.decrypt(password, autoGeneratedPassPhrase).toString(enc.Utf8);
  const encryptedPasswordName = AES.decrypt(passwordName, autoGeneratedPassPhrase).toString(enc.Utf8);
  const encryptedLink = link ? AES.decrypt(link, autoGeneratedPassPhrase).toString(enc.Utf8) : '';
  const encryptedUsername = username ? AES.decrypt(username, autoGeneratedPassPhrase).toString(enc.Utf8) : '';
  const decryptedPasswordRecord = {
    ...(link ? {link: encryptedLink} : {}),
    ...(username ? {username: encryptedUsername} : {}),
    password: encryptedPassword,
    passwordName: encryptedPasswordName,
    index,
  };

  return {
    passwordRecord: decryptedPasswordRecord,
    ...HttpsSuccess,
  };
};

export const secondRoundDecrypt = functions.https.onCall(secondRoundDecryptInternal);
